package com.oic.bookreminder.models.tables;

import java.util.List;
import com.oic.bookreminder.models.tables.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table USER.
 */
public class User {

    private Long id;
    private String userId;
    private String accessToken;
    private String gcmToken;
    private String displayName;
    private String fbId;
    private String fbAccessToken;
    private Long fbExpiredDate;
    private String fbEmail;
    private String fbUserName;
    private String privateEmail;
    private String avatarUrl;
    private Boolean isActivated;
    private Integer emailNotification;
    private String language;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient UserDao myDao;

    private List<Notification> notificationList;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public User() {
    }

    public User(Long id) {
        this.id = id;
    }

    public User(Long id, String userId, String accessToken, String gcmToken, String displayName, String fbId, String fbAccessToken, Long fbExpiredDate, String fbEmail, String fbUserName, String privateEmail, String avatarUrl, Boolean isActivated, Integer emailNotification, String language) {
        this.id = id;
        this.userId = userId;
        this.accessToken = accessToken;
        this.gcmToken = gcmToken;
        this.displayName = displayName;
        this.fbId = fbId;
        this.fbAccessToken = fbAccessToken;
        this.fbExpiredDate = fbExpiredDate;
        this.fbEmail = fbEmail;
        this.fbUserName = fbUserName;
        this.privateEmail = privateEmail;
        this.avatarUrl = avatarUrl;
        this.isActivated = isActivated;
        this.emailNotification = emailNotification;
        this.language = language;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getUserDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getGcmToken() {
        return gcmToken;
    }

    public void setGcmToken(String gcmToken) {
        this.gcmToken = gcmToken;
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public String getFbId() {
        return fbId;
    }

    public void setFbId(String fbId) {
        this.fbId = fbId;
    }

    public String getFbAccessToken() {
        return fbAccessToken;
    }

    public void setFbAccessToken(String fbAccessToken) {
        this.fbAccessToken = fbAccessToken;
    }

    public Long getFbExpiredDate() {
        return fbExpiredDate;
    }

    public void setFbExpiredDate(Long fbExpiredDate) {
        this.fbExpiredDate = fbExpiredDate;
    }

    public String getFbEmail() {
        return fbEmail;
    }

    public void setFbEmail(String fbEmail) {
        this.fbEmail = fbEmail;
    }

    public String getFbUserName() {
        return fbUserName;
    }

    public void setFbUserName(String fbUserName) {
        this.fbUserName = fbUserName;
    }

    public String getPrivateEmail() {
        return privateEmail;
    }

    public void setPrivateEmail(String privateEmail) {
        this.privateEmail = privateEmail;
    }

    public String getAvatarUrl() {
        return avatarUrl;
    }

    public void setAvatarUrl(String avatarUrl) {
        this.avatarUrl = avatarUrl;
    }

    public Boolean getIsActivated() {
        return isActivated;
    }

    public void setIsActivated(Boolean isActivated) {
        this.isActivated = isActivated;
    }

    public Integer getEmailNotification() {
        return emailNotification;
    }

    public void setEmailNotification(Integer emailNotification) {
        this.emailNotification = emailNotification;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Notification> getNotificationList() {
        if (notificationList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            NotificationDao targetDao = daoSession.getNotificationDao();
            List<Notification> notificationListNew = targetDao._queryUser_NotificationList(id);
            synchronized (this) {
                if(notificationList == null) {
                    notificationList = notificationListNew;
                }
            }
        }
        return notificationList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetNotificationList() {
        notificationList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
